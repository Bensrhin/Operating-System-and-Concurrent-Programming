/**
                        2A ISI at GRENOBLE-INP ENSIMAG
@author Nabil Bensrhier
@version final
@year 2019
*/
#include "malloc.c.h"
#include "processus.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"

extern uint32_t ligne_curseur;
extern uint32_t colonne_curseur;
extern void ctx_sw();

// struct processus *procs = malloc(N * sizeof(struct processus));



// pointeur vers le processus ELU
static struct processus *actif;


// tete et queue de la liste des activables
processus *t_actif = NULL;
processus *q_actif = NULL;

// tete et queue de la liste des mourants
processus *t_mourant = NULL;
processus *q_mourant = NULL;
// tete et queue de la liste des endormis
processus *t_endormi = NULL;
processus *q_endormi = NULL;

// nombre total des processus:
int nbProc = 0;

extern uint32_t clock_time;
/**************************************************************************/

void initialiser()
{
  // t_proc[0] = {0, "idle", ELU};
  processus *proc = malloc(sizeof(processus));
  proc->pid = 0;
  proc->nom_proc = "idle";
  // strcpy(proc->nom_proc, "idle");
  proc->etat = ELU;
  actif = proc;

}

/*****************************************************************************/

int32_t mon_pid(void){
  return actif->pid;
}

char *mon_nom(void){
  return actif->nom_proc;
}

/******************************************************************************/

char * etat(processus *proc)
{
  char * stat;
  if (proc->etat == ENDORMI) stat = "E";
  if (proc->etat == ACTIVABLE) stat = "A";
  if (proc->etat == MOURANT) stat = "M";
  return stat;
}
void affichage(){
  processus *a_cour = t_actif;
  processus *m_cour = t_mourant;
  processus *d_cour = t_endormi;
  uint32_t ligne = ligne_curseur;
  uint32_t colonne = colonne_curseur;
  efface_ecran(1, 4, 80);
  ligne_curseur = 1;
  colonne_curseur = 0;

  printf("%s : %i : %s \t", actif->nom_proc, actif->pid, "ELU");
  printf("\n");
  while (a_cour != NULL){
    printf("%s : %i , %s \t", a_cour->nom_proc, a_cour->pid, etat(a_cour));
    a_cour = (a_cour->suiv);
  }
  printf("\n");
  while (d_cour != NULL){
    printf("%s : %i , %s \t", d_cour->nom_proc, d_cour->pid, etat(d_cour));
    d_cour = (d_cour->suiv);
  }
  printf("\n");
  while (m_cour != NULL){
    printf("%s : %i , %s \t", m_cour->nom_proc, m_cour->pid, etat(m_cour));
    m_cour = (m_cour->suiv);
  }

  ligne_curseur = ligne;
  colonne_curseur = colonne;


}

/********************* endormir un processus pendant un certain temps *********/
//
void dors(uint32_t nbr_secs)
{
  actif->temps = nbr_secs + clock_time/50;
  // int pid_debut = actif->pid;
  processus * cour = actif;
  push_sleep(cour);
  actif = pull_front_list();
  ctx_sw(cour->zone_sauv, actif->zone_sauv);

}
void fin_processus(void)
{
  processus * cour = actif;
  push_dead(cour);
  actif = pull_front_list();
  ctx_sw(cour->zone_sauv, actif->zone_sauv);
}

void detruire(processus * proc)
{
  if (proc != NULL)
  {
    if (proc->nom_proc) free(proc->nom_proc);
    detruire(proc->suiv);
    free(proc);
    proc = NULL;
  }
}
/*******************************************************************************/

// le code de création et d’initialisation des processus
int32_t cree_processus(void (*code)(void), char *nom)
{
  char proc[5] = {0};
  strncpy(proc, nom, 4);
  printf("%s ", proc);
  if (strcmp(proc, "proc") == 0)
  {
    int num = (int)(nom[4]) - 48;
    if( (num <= N) & (num > 0) & (nbProc < N))
    {
      printf("%s ", proc);
      nbProc += 1;
      proc[4] = num+'0';
      printf("%s \n", proc);
      /************    création du processus    **********************/
      processus *cour = malloc(sizeof(processus));
      cour->nom_proc = malloc(strlen(nom) * sizeof(char));
      cour->pid = nbProc;
      strncpy(cour->nom_proc, proc, strlen(nom));
      cour->etat = ACTIVABLE;
      cour->zone_sauv[1] = (int)&(cour->pile)[511];
      (cour->pile)[511] = (int)code;
      // q_proc->suiv = cour;
      // q_proc = cour;
      /*****************************************************************/
      push_back_list(cour);
      return nbProc;
    }
    return -1;
  }
  else if (strcmp(proc, "idle") == 0){
    return 0;
  }
  return -1;
}
/***********************************************************************/

void ordonnance(void)
{
  t_endormi = reveil(t_endormi);
  detruire(t_mourant);
  t_mourant = NULL;
  affichage();
  // int pid_debut = actif->pid;
  processus * cour = actif;
  push_back_list(cour);
  actif = pull_front_list();
  ctx_sw(cour->zone_sauv, actif->zone_sauv);
}

/*********************************************************/

struct processus * reveil(struct processus *cour)
{
  while (cour != NULL)
  {

    if (cour->temps < (clock_time/50))
    {
      // int pid_debut = cour->pid;
      processus *reveil = cour;
      cour = cour->suiv;
      push_back_list(reveil);

    }
    else{
      return cour;
    }

  }
  return  NULL;
}
/************** stocker le processus endormis ************/
void push_sleep(struct processus *proc)
{
  proc->etat = ENDORMI;
  proc->suiv = NULL;

  if (t_endormi == NULL)
  {
    t_endormi = proc;
    q_endormi = proc;
    return;
  }
  if (proc->temps < t_endormi->temps)
  {
    proc->suiv = t_endormi;
    t_endormi = proc;
    return;
  }
  struct processus *cour = t_endormi;
  while (cour->suiv != NULL)
  {

    if (proc->temps < (cour->suiv)->temps)
    {
      proc->suiv = cour->suiv;
      cour->suiv = proc;
      return;
    }
    cour = cour->suiv;
  }
  cour->suiv = proc;

}
/****** inserer un processus en q_actif de la liste des activables ************/
void push_back_list(struct processus *proc)
{
  proc->suiv = NULL;
  proc->etat = ACTIVABLE;
  if (t_actif == NULL)
  {
    t_actif = proc;
    q_actif = proc;
    return;
  }
  q_actif->suiv = proc;
  q_actif = q_actif->suiv;

}

/****** inserer un processus en queue de la liste des mourant ************/
void push_dead(processus *proc)
{
  proc->suiv = NULL;
  proc->etat = MOURANT;
  if (t_mourant == NULL)
  {
    t_mourant = proc;
    q_mourant = proc;
    return;
  }
  q_mourant->suiv = proc;
  q_mourant = q_mourant->suiv;

}
/*************************************************************/

processus * pull_front_list(){
  // extraction de la tête des activables
  // int pid = t_actif->pid;
  processus* cour = t_actif;
  t_actif = t_actif->suiv;
  cour->etat = ELU;
  return cour;
}


////////////////////////////////////////////////////////////////////////////////

void idle(void)
{
  for (;;) {
    printf("[temps = %u] processus %s pid = %i\n", clock_time/50, mon_nom(),
           mon_pid());
    sti();
    hlt();
    cli();
  }
}
void proc1(void)
{
  for (int32_t i=0;i<2;i++)
  {
    printf("[temps = %u] processus %s pid = %i\n", clock_time/50, mon_nom(),
           mon_pid());
    dors(2);
  }
  fin_processus();
}
void proc2(void)
{
  for (int32_t i=0;i<2;i++)
  {
    printf("[temps = %u] processus %s pid = %i\n", clock_time/50, mon_nom(),
           mon_pid());
    dors(3);
  }
  fin_processus();
}
void proc3(void)
{
  for (int32_t i=0;i<2;i++)
  {
    printf("[temps = %u] processus %s pid = %i\n", clock_time/50, mon_nom(),
           mon_pid());
    dors(5);
  }
  fin_processus();
}
void proc4(void)
{
  for (int32_t i=0;i<2;i++)
  {
    printf("[temps = %u] processus %s pid = %i\n", clock_time/50, mon_nom(),
           mon_pid());
    dors(7);
  }
  fin_processus();
}
void proc5(void)
{
  for (int32_t i=0;i<2;i++)
  {
    printf("[temps = %u] processus %s pid = %i\n", clock_time/50, mon_nom(),
           mon_pid());
    dors(10);
  }
  fin_processus();
}
void proc6(void)
{
  for (int32_t i=0;i<2;i++)
  {
    printf("[temps = %u] processus %s pid = %i\n", clock_time/50, mon_nom(),
           mon_pid());
    dors(12);
  }
  fin_processus();
}
void proc7(void)
{
  for (int32_t i=0;i<2;i++)
  {
    printf("[temps = %u] processus %s pid = %i\n", clock_time/50, mon_nom(),
           mon_pid());
    dors(15);
  }
  fin_processus();
}
// void idle(void){
//   printf("[idle] je tente de passer la main a proc1...\n");
//   printf("[%s] pid = %i\n", mon_nom(), mon_pid());
//   sti();
//   // ordonnance();
//   printf("[idle] un proc m’a redonne la main\n");
//   printf("[idle] je bloque le systeme\n");
//   hlt();
// }
// void proc1(void){
//   printf("[proc%i] idle m’a donne la main\n", mon_pid());
//   printf("[%s] pid = %i\n", mon_nom(), mon_pid());
//   // ordonnance();
// }
// void proc2(void){
//   printf("[proc%i] proc%i m’a donne la main\n", mon_pid(), mon_pid() - 1);
//   printf("[%s] pid = %i\n", mon_nom(), mon_pid());
//   sti();
//   // ordonnance();
// }
// void proc3(void){
//   printf("[proc%i] proc%i m’a donne la main\n", mon_pid(), mon_pid() - 1);
//   printf("[%s] pid = %i\n", mon_nom(), mon_pid());
//   sti();
//   // ordonnance();
// }
// void proc4(void){
//   printf("[proc%i] proc%i m’a donne la main\n", mon_pid(), mon_pid() - 1);
//   printf("[%s] pid = %i\n", mon_nom(), mon_pid());
//   sti();
//   // ordonnance();
// }
// void proc5(void){
//   printf("[proc%i] proc%i m’a donne la main\n", mon_pid(), mon_pid() - 1);
//   printf("[%s] pid = %i\n", mon_nom(), mon_pid());
//   sti();
//   // ordonnance();
// }
// void proc6(void){
//   printf("[proc%i] proc%i m’a donne la main\n", mon_pid(), mon_pid() - 1);
//   printf("[%s] pid = %i\n", mon_nom(), mon_pid());
//   sti();
//   // ordonnance();
// }
// void proc7(void){
//   printf("[proc%i] proc%i m’a donne la main\n", mon_pid(), mon_pid() - 1);
//   printf("[%s] pid = %i\n", mon_nom(), mon_pid());
//   sti();
//   // ordonnance();
// }

///////////////////////////////////////////////////////////////////////////////
// le code de création et d’initialisation des processus
// int32_t cree_processus(void (*code)(void), char *nom){
//   char proc[5] = {0};
//   strncpy(proc, nom, 4);
//   printf("%s ", proc);
//   if (strcmp(proc, "proc") == 0){
//     int num = (int)(nom[4]) - 48;
//
//     if( (num <= 7) & (num > 0) & (nbProc < 8)) {
//       printf("%s ", proc);
//       nbProc += 1;
//       proc[4] = num+'0';
//       printf("%s \n", proc);
//       ///
//       t_proc[num].pid = num;
//       strcpy(t_proc[0].nom_proc, proc);
//       t_proc[num].etat = ACTIVABLE;
//       t_proc[num].zone_sauv[1] = (int)&(t_proc[num].pile)[511];
//       (t_proc[num].pile)[511] = (int)code;
//       return num;
//     }
//     return -1;
//   }
//   else if (strcmp(proc, "idle") == 0){
//     return 0;
//   }
//   return -1;
// }
///////////////////////////////////////////////////////////////////////////////

// void ordonnance(void){
//
//   int pid = actif.pid;
//   int pid_debut = actif.pid;
//   while (t_proc[pid].etat != ACTIVABLE)
//   {
//     pid += 1;
//     pid = pid % N;
//
//   }
//   t_proc[pid_debut].etat = ACTIVABLE;
//   t_proc[pid].etat = ELU;
//   actif = t_proc[pid];
//
//   // insertion(actif);
//   // actif = *extraction();
//   ctx_sw(t_proc[pid_debut].zone_sauv, t_proc[pid].zone_sauv);
// }
///////////////////////////////////////////////////////////////////////////////
// void insertion(struct processus *elu){
//   q_actif->suiv = elu;
//   q_actif = q_actif->suiv;
//   q_actif->etat = ACTIVABLE;
// }

////////////////////////////////////////////////////////////////////////////////
// processus * get_q_actif()
// {
//   if (t_actif == NULL)
//   {
//     return NULL;
//   }
//   printf("t_actif : %i , %s \n", t_actif->pid, t_actif->nom_proc);
//   processus *temp;
//   temp = t_actif;
//   printf("tem : %i , %s \n", temp->pid, temp->nom_proc);
//   while (temp->suiv != NULL)
//   {
//     temp = temp->suiv;
//   }
//   return temp;
// }
