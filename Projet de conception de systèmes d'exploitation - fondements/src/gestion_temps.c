#include "processus.h"
#include "cpu.h"
#include "inttypes.h"
#include "string.h"
#include "stdio.h"
#include "affichage.h"
#include "stdbool.h"
#include "segment.h"
#define const 0x8E00
#define vecteur_it 0x1000
#define quartz 0x1234DD

extern uint32_t ligne_curseur;
extern uint32_t colonne_curseur;

void affichage_horloge(char *c){
  uint32_t ligne = ligne_curseur;
  uint32_t colonne = colonne_curseur;
  ligne_curseur = 0;
  colonne_curseur = 80-strlen(c);
  console_putbytes(c, 8);
  ligne_curseur = ligne;
  colonne_curseur = colonne;
}

extern uint32_t clock_time;
/* écrire le traitant de l'interruption 32 qui affiche à l'écran le temps écoulé
depuis le démarrage du système :

1) ce traitant commence par une partie en assembleur pour sauvegarder les registres
(qui est fournie dans le fichier traitant.S),
2) mais l'acquittement de l'interruption et la partie gérant l'affichage doit être
faite dans une fonction en C */
void tic_PIT(void){
  // l'acquittement de l'interruption
  //en pratique, tout au début de la partie C du traitant
  outb(0x20, 0x20);
  clock_time += 1; // 50 hz = 20ms
  char horloge[12];
  uint32_t second = clock_time / 50;
  sprintf(horloge, "%02d:%02d:%02d", second/3600, (second%3600)/60, second%60);
  affichage_horloge(horloge);
  ordonnance();
}

void init_traitant_IT(int32_t num_IT, void (*traitant)(void)){

  uint32_t premier_mot = (KERNEL_CS << 16) | ((uint32_t )traitant&0xffff);
  uint32_t deuxieme_mot = ((uint32_t)traitant & 0xffff0000) | 0x8E00 ;
  uint32_t *vecteur_inter = (uint32_t *) vecteur_it;
  vecteur_inter[2*num_IT] = premier_mot;
  vecteur_inter[2*num_IT + 1] = deuxieme_mot;

}

void regler_horloge(void){
  uint32_t QUARTZ = 0x1234DD;
  uint32_t CLOCKFREQ = 50;
  // on envoie la commande sur 0x34 sur le port de commande 0x43 :
  outb(0x34, 0x43);
  //on envoie les 8 bits de poids faibles de la valeur de réglage de la fréquence
  //sur le port de données 0x40
  outb((QUARTZ / CLOCKFREQ) % 256, 0x40);
  //on envoie ensuite les 8 bits de poids forts de la valeur de réglage sur
  //le même port 0x40
  outb(((QUARTZ / CLOCKFREQ) >> 8) & 0xFF, 0x40);
}
void masque_IRQ(uint32_t num_IRQ, bool masque){
  //l faut d’abord lire la valeur actuelle du masque sur le port de données 0x21
  uint8_t tab = inb(0x21);
  if (masque){
    outb(tab | (1 << num_IRQ), 0x21);
  }
  else{
    outb(tab & ~(1 << num_IRQ), 0x21);
  }
}
// démasquer les interruptions externes grâce à un appel à la fonction sti()
//comme expliqué dans le squelette de code donné plus haut.
